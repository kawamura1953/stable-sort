タイトル　：　qsortの実装がマージソートである訳　高速で安定なソートとは？

安定な比較ソートssort(stable sort)(ss14g1)を作成しました。
これの性能評価で悩んでいます。

https://ja.wikipedia.org/wiki/ソート
にあるように、ソートには安定なソートと安定でないソートがあります。

newlibのqsortのソースコードを読むと、伝統的なアルゴリズムによる実装です。
これは安定でないソートです。

一方、glibcのqsortのソースコードを読むと
その実装は、クイックソートではなくマージソートで実装されています。
マージソートは安定なソートです。

newlib・glibc の qsort の性能を比較すると、
ソート条件（キー値の分布・要素数・要素サイズ）により、速い/遅いが入れ替わります。

マージソートでは、社員番号のようにキーが同値をもたないとき、
「比較関数の呼出し回数」が少なくなります。（伝統的qsortに比べてほんの僅かですが）
その代償として、県名のようにキーが同値をもつとき、
「比較関数の呼出し回数」と「要素の移動回数」がともに多くなります。

さて、私が用意したほとんどのソート条件において、ssortはglibcのqsortより高速です。
qs_glibcとss14g1の実行したときの 比較関数の呼出し回数・実行時間 を以下に示します。
qs_glibcは、glibcのqsortを実験用に改造したものです。

速さだけでなく、必要な作業領域にも大きな差があります。
glibcのqsortでは概算で (8+8)*n バイト必要です。（sizeof(char*)=8,要素数=n）
ssortなら (8+2)*n バイトで済みます。（sizeof(short int)=2）

なぜglibcのqsortはマージソートを採用しているのでしょうか？
「最悪計算時間が短いから」では補えないほど、平均計算時間が遅いと思うのですが・・・
何かご存じの方はお教えいただけないでしょうか。




----------------- benchmark.txt begin -------------------- 
 
キー種別:乱数　要素数:1万個　要素サイズ:8,20,400byte 
qs_glibc d=-3 e=10000 s=8 R5000 M000:000:000:0: c=120451  602257294   T=12.11  242 
ss14g1   d=-3 e=10000 s=8 R5000 M090:200:000:0: c=129440  647203516   T=12.53  251 
 
qs_glibc d=-3 e=10000 s=20 R4000 M000:000:000:0: c=120451  481804645  T=29.91  748 
ss14g1   d=-3 e=10000 s=20 R4000 M090:200:000:0: c=129432  517729992  T=10.28  257 
 
qs_glibc d=-3 e=10000 s=400 R2000 M000:000:000:0: c=120449  240899735 T=10.90  545 
ss14g1   d=-3 e=10000 s=400 R2000 M090:200:000:0: c=129414  258828893 T=10.31  516 
 
キー種別:100種　要素数:1万個　要素サイズ:8,20,400byte 
qs_glibc d=100 e=10000 s=8 R6000 M000:000:000:0: c=120211  721269066   T=13.09  218 
ss14g1   d=100 e=10000 s=8 R6000 M090:200:000:0: c=62523   375140861   T= 8.44  141 
 
qs_glibc d=100 e=10000 s=20 R5000 M000:000:000:0: c=120211  601058260  T=36.01  720 
ss14g1   d=100 e=10000 s=20 R5000 M090:200:000:0: c=62523   312616709  T= 7.13  143 
 
qs_glibc d=100 e=10000 s=400 R2000 M000:000:000:0: c=120212  240424496 T=10.14  507 
ss14g1   d=100 e=10000 s=400 R2000 M090:200:000:0: c=62504   125008089 T= 7.57  378 
 
キー種別:2種　要素数:1万個　要素サイズ:8,20,400byte 
qs_glibc d=2 e=10000 s=8 R8000 M000:000:000:0: c=94725   757804948   T=12.15  152 
ss14g1   d=2 e=10000 s=8 R8000 M090:200:000:0: c=15120   120964685   T= 4.65   58 
 
qs_glibc d=2 e=10000 s=20 R8000 M000:000:000:0: c=94725   757804948  T=43.35  542 
ss14g1   d=2 e=10000 s=20 R8000 M090:200:000:0: c=15120   120964685  T= 4.79   60 
 
qs_glibc d=2 e=10000 s=400 R3000 M000:000:000:0: c=94732   284197358 T=12.70  423 
ss14g1   d=2 e=10000 s=400 R3000 M090:200:000:0: c=15121    45364669 T= 7.66  255 
 
 
キー種別:10種　要素数:1万,10万,100万個　要素サイズ:1000byte 
qs_glibc d=10 e=10000 s=1000 R2000 M000:000:000:0: c=116416  232833027   T=13.96    698 
ss14g1   d=10 e=10000 s=1000 R2000 M090:200:000:0: c=30010    60020710   T=10.73    537 
 
qs_glibc d=10 e=100000 s=1000 R100 M000:000:000:0: c=1479708  147970872  T=10.26  10263 
ss14g1   d=10 e=100000 s=1000 R100 M090:200:000:0: c=291330    29133013  T= 7.27   7268 
 
qs_glibc d=10 e=1000000 s=1000 R10 M000:000:000:0: c=17952422  179524224 T=12.78 127750 
ss14g1   d=10 e=1000000 s=1000 R10 M090:200:000:0: c=2911052    29110528 T= 8.21  82050 
 
=================  benchmark.txt end  ==================== 
各行の最後の数値がソート１回あたりの処理時間(10μ秒単位)です 
